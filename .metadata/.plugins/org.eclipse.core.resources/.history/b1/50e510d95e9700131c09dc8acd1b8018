/**
 * @author Robert Mina (ram2aq)
 * @author Jenny Xing (yx4qu)
 * 
 * Class for an n-dimensional tic-tac-toe board using magic n-cubes to determine winner
 */

import java.util.*;

public class genTTTBoard {

	private int size;
	private int magicNum;
	private int dimension;
	private String player0;
	private String player1;
	private HashMap<Integer, String> boardMap;
	private HashMap<Integer, Integer> magicSquare;
	private TreeSet<Integer> player0Spots;
	private TreeSet<Integer> player1Spots;
	private TreeSet<Integer> openSpots;
	private TreeSet<Integer> player0Pairs;
	private TreeSet<Integer> player1Pairs;
	
	final int MAX_SPACES = 1000000;

	public static void main(String args[]) {

	}

	public genTTTBoard(Integer size, String p0, String p1) {
		this.size = size;
		magicNum = (size * (pow(size,dimension) + 1)) / 2;
		player0 = p0;
		player1 = p1;
		boardMap = new HashMap<Integer, String>(size * size, (float) 1.0);
		magicSquare = new HashMap<Integer, Integer>(size * size, (float) 1.0);
		loadMagicSquare();
		player0Spots = new TreeSet<Integer>();
		player1Spots = new TreeSet<Integer>();
		openSpots = new TreeSet<Integer>();
		loadOpenSpots();
		player0Pairs = new TreeSet<Integer>();
		player1Pairs = new TreeSet<Integer>();
	}
	
	public int getSize() { return size; }
	
	public HashMap<Integer, String> getBoardMap() { return boardMap; }
	
	public int getDimension() { return dimension; }
	
	//simple method to return x^exp for ints
	private int pow(int x, int exp) {
		int retval = 1;
		while (true) {
			if (exp == 0) break;
			retval *= x;
			exp--;
		}
		return retval;
	}
	
	//load all possible key values into openSpots set
	private void loadOpenSpots() {
		for (int i=0; i<pow(size, dimension); i++) {
			openSpots.add(i);
		}
	}

	// load Integer values into the correct values in the magicSquare map
	//TODO: implement for n-dimensions
	private void loadMagicSquare() {

	}

	// params row and col: coordinates within the square (0 to
	// size^2-1)
	// return int key corresponding to the key in the maps for those coords
	private int getKey(int row, int col) {
		return size * row + col;
	}

	// param player: 0 or 1, the player number
	// params row and col: coordinates within the square
	// return boolean true if move successful, false otherwise
	private boolean move(int player, int row, int col) {
		if (!openSpots.contains(getKey(row,col))) {
			//already occupied or invalid coords
			return false;
		}
		if (player != 0 && player != 1) { // invalid player
			return false;
		}
		// valid move
		updatePairs(getKey(row,col),player); //update pairs set
		boardMap.put(getKey(row, col), player == 1 ? player1 : player0);
		if (player == 1) {
			player1Spots.add(magicSquare.get(getKey(row, col)));
		} else {
			player0Spots.add(magicSquare.get(getKey(row, col)));
		}
		openSpots.remove(getKey(row,col));
		check(player); //check for winning move and draw, check for win is redundant
		return true;
	}
	
	//update pairs set for player to include all new possible pairs
	//if the last move was a winning one, call win() method
	//NOTE: the current move has NOT been added to the spots set
	private boolean updatePairs(int key, int player) {
		if (player != 0 && player != 1) { // invalid player
			return false;
		}
		if (key >= size*size) { // invalid coords
			return false;
		}
		TreeSet<Integer> pairs = (player == 0) ? player0Pairs : player1Pairs;
		TreeSet<Integer> spots = (player == 0) ? player0Spots : player1Spots;
		String playerS = (player == 0) ? player0 : player1;
		int value = magicSquare.get(key);
		int[] nPair = new int[size];
		int[] nIndices = new int[size-1];
		nPair[size-1] = value; //last value in nPair is the previous move
		ArrayList<Integer> spotsList = new ArrayList<Integer>(spots);
		for (int i = 0; i < spotsList.size() - size - 1; i++) {
			// loop over elements in the list, grabbing each possible
			// combination of size-1 spots
			for (int j = 0; j < size - 2; j++) { // assign indices
				nIndices[j] = i + j;
				nPair[j] = spotsList.get(nIndices[j]);
			} // indices default to first unchecked size elements
			while (true) {
				int sum = sum(nPair);
				if (sum == magicNum) {
					win(playerS);
					return true; // player has won with latest move
				}
				pairs.add(sum);
				if (nIndices[size - 1] == spotsList.size()-1)
					break; // no more nPairs with this first value
				for (int j = size - 2; j >= 0; j--) {
					nIndices[j]++;
					nPair[j] = spotsList.get(nIndices[j]);

				}
			}
		}
		return true;
	}

	// check for win or draw conditions
	// update the relevant player pairs set to include pairs wit
	//NOTE: the current move HAS been added to relevant pairs set
	//param player: 0 or 1, the player number
	private boolean check(int player) {
		if (player != 0 && player != 1) { // invalid player
			return false;
		}
		//checkWin() // deprecated
		TreeSet<Integer> pairs = (player == 0) ? player0Pairs : player1Pairs;
		String winner = (player == 0) ? player0 : player1; //not necessarily the winner yet
		if (pairs.contains(magicNum)) { //should be redundant
			win(winner);
			return true;
		}
		checkDraw();
		return true;
	}
	
	
	//method to check for draw condition
	//TODO: currently only checks that all spaces are filled
	//TODO: draw condition can occur before this is true
	private void checkDraw() {
		if (openSpots.size() == 0)
			draw();
	}
	
	//perform draw operation
	private void draw() {
		
	}
	
	
	//deprecated method to check if there is a winner
	private void checkWin() {
		if (player0Spots.size() < size && player1Spots.size() < size)
			return; // not possible that someone has won
		int[] nPair = new int[size];
		int[] nIndices = new int[size];
		ArrayList<Integer> player0SpotsList = new ArrayList<Integer>(
				player0Spots);
		for (int i = 0; i < player0SpotsList.size() - size; i++) {
			// loop over elements in the list, grabbing each possible
			// combination of size spots and seeing if they sum to the magic
			// number
			for (int j = 0; j < size - 1; j++) { // assign indices
				nIndices[j] = i + j;
				nPair[j] = player0SpotsList.get(nIndices[j]);
			} // indices default to first unchecked size elements
			while (true) {
				int sum = sum(nPair);
				if (sum == magicNum) {
					win(player0);
					return;
				} else if (sum > magicNum)
					break; // continue to next starting digit
				else { // re-assign indices and nPair
					if (nIndices[size - 1] == player0SpotsList.size()-1)
						break; // no more nPairs with this first value
					for (int j = size - 1; j >= 0; j--) {
						nIndices[j]++;
						nPair[j] = player0SpotsList.get(nIndices[j]);
					}
				}
			}
		}
		ArrayList<Integer> player1SpotsList = new ArrayList<Integer>(
				player1Spots);
		for (int i = 0; i < player1SpotsList.size() - size; i++) {
			// loop over elements in the list, grabbing each possible
			// combination of size spots and seeing if they sum to the magic
			// number
			for (int j = 0; j < size - 1; j++) { // assign indices
				nIndices[j] = i + j;
				nPair[j] = player1SpotsList.get(nIndices[j]);
			} // indices default to first unchecked size elements
			while (true) {
				int sum = sum(nPair);
				if (sum == magicNum) {
					win(player1);
					return;
				} else if (sum > magicNum)
					break; // continue to next starting digit
				else { // re-assign indices and nPair
					if (nIndices[size - 1] == player1SpotsList.size()-1)
						break; // no more nPairs with this first value
					for (int j = size - 1; j >= 0; j--) {
						nIndices[j]++;
						nPair[j] = player1SpotsList.get(nIndices[j]);
					}
				}
			}
		}
	}

	private int sum(int[] nPair) {
		int retval = 0;
		for (int i = 0; i < size; i++) {
			retval += nPair[i];
		}
		return retval;
	}

	// perform the winning operation given the winner
	private void win(String winner) {

	}

	// prints magic square in row-major oder
	private void printMagicSquare() {
		System.out.println("start");
		for (int row = 0; row < size; row++) {
			for (int col = 0; col < size; col++) {
				// System.out.println("(" + row + ", " + col + "): "
				// + magicSquare.get(getKey(row, col)));
				if (magicSquare.containsKey(getKey(row, col))) {
					int value = magicSquare.get(getKey(row, col));
					System.out.print(value);
					if (value < 10000)
						System.out.print(" ");
					if (value < 1000)
						System.out.print(" ");
					if (value < 100)
						System.out.print(" ");
					if (value < 10)
						System.out.print(" ");
				}
			}
			System.out.println();
		}
		System.out.println("end");
	}

	// x and y are the keys
	private void swapValues(int x, int y) {
		int xval = magicSquare.get(x);
		int yval = magicSquare.get(y);
		magicSquare.put(x, yval);
		magicSquare.put(y, xval);
	}
	
	
}
